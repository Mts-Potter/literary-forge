import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { BedrockRuntimeClient, InvokeModelCommand } from '@aws-sdk/client-bedrock-runtime'
import { sceneDescriptionSchema } from '@/lib/validation/api-schemas'
import { z } from 'zod'
import { logError, getSafeErrorMessage } from '@/lib/utils/error-logger'

const bedrockClient = new BedrockRuntimeClient({
  region: process.env.AWS_REGION!,
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!
  }
})

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    // Auth check
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // SECURITY M-2: Rate limiting
    const forwardedFor = request.headers.get('x-forwarded-for')
    const clientIp = forwardedFor ? forwardedFor.split(',')[0].trim() : '127.0.0.1'

    const { data: hasQuota, error: quotaError } = await supabase.rpc('check_and_consume_quota', {
      p_user_id: user.id,
      p_ip_address: clientIp
    })

    if (quotaError || !hasQuota) {
      return NextResponse.json(
        { error: 'Rate limit exceeded. Please try again later.' },
        { status: 429 }
      )
    }

    // SECURITY M-3: Input validation
    const body = await request.json()

    const requestSchema = z.object({
      text_id: z.string().uuid('Invalid text ID format'),
      content: z.string().min(10, 'Content must be at least 10 characters').max(100_000, 'Content too long')
    })

    let validatedData
    try {
      validatedData = requestSchema.parse(body)
    } catch (err) {
      if (err instanceof z.ZodError) {
        return NextResponse.json(
          {
            error: 'Validation failed',
            details: err.issues.map(e => `${e.path.join('.')}: ${e.message}`)
          },
          { status: 400 }
        )
      }
      throw err
    }

    const { text_id, content } = validatedData

    // Call Bedrock to generate scene description
    const prompt = `Summarize the main literary content in this passage in 2-3 sentences. Focus on:
- Setting (where/when the scene takes place)
- Characters (who is present)
- Main action (what happens)

IMPORTANT RULES:
1. Skip any Project Gutenberg license/copyright header text at the beginning
2. Find the actual story content (usually starts after headers/metadata)
3. Summarize ONLY the narrative/literary portion
4. If the passage is a fragment (starts mid-sentence or lacks clear context), summarize what's actually present without apologizing
5. NEVER output meta-commentary like "I apologize" or "this appears to be a fragment" - just describe what you can

Do NOT describe writing style, tone, or literary techniques. Keep it factual and neutral.

TEXT:
${content}

Output ONLY the summary of the story content. Even if incomplete, describe what is present. No apologies or explanations.`

    const input = {
      modelId: process.env.BEDROCK_MODEL_ID || 'us.anthropic.claude-3-5-haiku-20241022-v1:0',
      contentType: 'application/json',
      accept: 'application/json',
      body: JSON.stringify({
        anthropic_version: 'bedrock-2023-05-31',
        max_tokens: 500,
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.5
      })
    }

    const command = new InvokeModelCommand(input)
    const response = await bedrockClient.send(command)

    // Decode Bedrock response
    const responseBody = JSON.parse(new TextDecoder().decode(response.body))
    const description = responseBody.content?.[0]?.text?.trim()

    if (!description) {
      throw new Error('No description generated by Bedrock')
    }

    // Detect error/apologetic responses from Bedrock (treated as failures)
    const errorPatterns = [
      /i apologize/i,
      /i cannot/i,
      /does not contain/i,
      /appears to be a fragment/i,
      /without more context/i,
      /insufficient/i,  // Catches "insufficient narrative context", "insufficient information", etc.
      /unable to/i,
      /there is insufficient/i,
      /lacks a clear/i,
      /based on the provided text fragment/i  // Common meta-commentary
    ]

    const isErrorResponse = errorPatterns.some(pattern => pattern.test(description))

    if (isErrorResponse) {
      console.log('Bedrock returned error/apologetic message, using fallback excerpt')

      // Use fallback: first ~200 characters as a literal excerpt
      const fallbackDescription = content.trim().substring(0, 200) + (content.length > 200 ? '...' : '')

      // Cache the fallback
      const { data: existingText } = await supabase
        .from('source_texts')
        .select('metadata')
        .eq('id', text_id)
        .single()

      const updatedMetadata = {
        ...existingText?.metadata,
        plot_summary: fallbackDescription,
        generated_at: new Date().toISOString(),
        generation_method: 'fallback_excerpt'
      }

      await supabase
        .from('source_texts')
        .update({ metadata: updatedMetadata })
        .eq('id', text_id)

      return NextResponse.json({ description: fallbackDescription })
    }

    // Cache in database (update metadata.plot_summary)
    const { data: existingText } = await supabase
      .from('source_texts')
      .select('metadata')
      .eq('id', text_id)
      .single()

    const updatedMetadata = {
      ...existingText?.metadata,
      plot_summary: description,
      generated_at: new Date().toISOString()
    }

    const { error: updateError } = await supabase
      .from('source_texts')
      .update({ metadata: updatedMetadata })
      .eq('id', text_id)

    if (updateError) {
      console.error('Failed to cache description in DB:', updateError)
      // Non-critical error - still return description
    }

    return NextResponse.json({ description })
  } catch (error: any) {
    // SECURITY M-5: Secure error handling - log full details server-side, return generic message
    logError('generate-scene-description', error)
    return NextResponse.json(
      { error: getSafeErrorMessage(error) },
      { status: 500 }
    )
  }
}
